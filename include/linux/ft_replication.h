/*
 * ft_replication.h
 *
 * Author: Marina
 */

#ifndef FT_REPLICATION_H_
#define FT_REPLICATION_H_

#include <linux/list.h>
#include <linux/kref.h>
#include <linux/spinlock_types.h>
#include <linux/wait.h>
#include <linux/popcorn.h>

#define FT_POPCORN

#define SUPPORT_FOR_CLUSTERING
/* int replica_type of struct task_struct can be only one of the 
 * following:
 */
#define FT_NOT_REPLICATED 0
#define FT_PRIMARY_REPLICA 1
#define FT_SECONDARY_REPLICA 2
#define FT_POTENTIAL_PRIMARY_REPLICA 3
#define FT_POTENTIAL_SECONDARY_REPLICA 4
#define FT_ROOT_POT_PRIMARY_REPLICA 5
#define FT_REPLICA_DESCENDANT 6
#define FT_NEW_PRIMARY_REPLICA_DESCENDANT 7
#define FT_NEW_SECONDARY_REPLICA_DESCENDANT 8
#define FT_PRIMARY_AFTER_SECONDARY 9
#define FT_NEW_PRIMARY_AFTER_SECONDARY_DESCENDANT 10
#define FT_POTENTIAL_PRIMARY_REPLICA_AFTER_SECONDARY 11
/****/

#define WAIT_ANSWER_TIMEOUT_SECOND 5
#define WAIT_PCKT_MAX 5
#define WAIT_CROSS_FILTER_MAX 1

/*by seeing include/asm-generic/errno.h seems to be the next available...*/
#define ENOFTREP 134

/* int filter_type of struct socket can be only one of
 * the following:
 */
#define FT_FILTER_DISABLE 0x0
#define FT_FILTER_ENABLE 0x1
/****/

/* int type of struct net_filter_info can be one 
 * of the previous used for struct socket,
 * masked with one of the following:
 */
#define FT_FILTER_SECONDARY_REPLICA 0x2
#define FT_FILTER_PRIMARY_REPLICA 0x4
#define FT_FILTER_PRIMARY_AFTER_SECONDARY_REPLICA 0x40

#define FT_FILTER_FAKE 0x8
#define FT_FILTER_CHILD 0x10
/****/

/* Linux-like identifier for a replica.
 * It is the standard pid_t of the thread and the kernel
 * id that gave that pid.
 *
 * NOTE: each replica will have its own pid in the kernel in which
 * it is running => replicas do no share this identifier.
 */
struct replica_id{
        int kernel;
        pid_t pid;
};

struct replica_id_list{
        struct list_head replica_list_member;
        struct replica_id replica;
};

/* Identifier used by struct ft_pop_rep.
 * 
 * Groups of replicas on different kernels that are associated 
 * (they are generated by the same replicated process)
 * will have the same identifier.
 */
struct ft_pop_rep_id{
        int kernel;
        int id;
};

/* Identifier for replicas in ft-popcorn.
 * The same replica in different kernels will have the same ft_pid.
 * It is a one-to-one mapping for each replicated thread in popcorn
 * (the same replicated thread will have the same ft_pid in all kernels).
 */
#define MAX_GENERATION_LENGTH 5
struct ft_pid{
        int level;
        int id_array[MAX_GENERATION_LENGTH];
	struct ft_pop_rep_id ft_pop_id;
};
int are_ft_pid_equals(struct ft_pid* first, struct ft_pid* second);
char* print_ft_pid(struct ft_pid* pid);

/* This is a struct with all replication info need by a group of replica.
 * 
 * The struct is supposed to be created by the first thread that is replicated
 * on a kernel (the primary or secondary replicas) and shared after with all its descendants
 * (which compose the replica group on a kernel)
 * 
 * The corresponding replica groups in different kernels will have the same
 * struct ft_pop_rep_id identifier.
 */
struct ft_pop_rep{
	struct kref kref;
	struct ft_pop_rep_id id;
	int replication_degree;
	struct replica_id primary_replica;
	struct replica_id_list secondary_replicas_head;
};
void get_ft_pop_rep(struct ft_pop_rep* ft_pop);
void put_ft_pop_rep(struct ft_pop_rep* ft_pop);

struct sk_buff;
struct ft_sk_buff_list{
	struct list_head list_member;
	struct sk_buff* skbuff;
	long long pckt_id;
	__wsum csum;
};

struct socket;
struct sock;

struct tcp_init_param{
        __u32 write_seq;
        __u16 inet_id;
        __be16 sport;
        __be16 dport;
        __be32 daddr;
        __be32 saddr;
        __be32 rcv_saddr;
	__u32 snt_isn;
	__u32 snt_synack;
};

struct stable_buffer;
struct send_buffer;
struct iovec;
struct request_sock;
struct inet_timewait_sock;

/* struct used for networking filter on ft-popcorn.
 * 
 * If replicated, each socket will have its own reference to a filter
 * defined by this struct.
 * 
 * The filter is uniquely identied in a kernel by its ft-pid and id,
 * but same groups of replicas in different kernels will generate the same
 * filter identifiers from the same corresponding sockets.
 */
struct net_filter_info{
	struct list_head list_member;
	struct kref kref;
	struct ft_pop_rep* ft_popcorn;

	/*those fields could be collapsed on a union...*/
	struct sock* ft_sock;
	struct request_sock* ft_req; //to use only if it is still a minisocket at the place of ft_sock
	struct inet_timewait_sock* ft_time_wait; //to use only when in TCP_TIME_WAIT and struct sock is beeing substituted by a struct inet_timewait_sock	

	/* NOTE creator and id compose the identifier.
	 * correspondig sockets between kernels will have the same 
	 * idetifier.
	 * In case the filter is a child filter, also daddr and dport 
	 * of tcp param are part of the identifier.
	 */
	struct ft_pid creator;
	int id;

	volatile int type;
	spinlock_t lock;
	volatile long long local_tx;
	volatile long long primary_tx;
	long long local_rx;
	long long primary_rx;
	wait_queue_head_t* wait_queue;
	struct workqueue_struct *rx_copy_wq;
	struct ft_sk_buff_list skbuff_list;

	volatile int primary_connect_id;
	int local_connect_id;
	volatile int primary_accept_id;
        int local_accept_id;
	struct tcp_init_param tcp_param;

	/* deliver_packets can be 
	 * 0: do not deliver pckt
	 * 1: always deliver pckt:
	 * 2: inforce same order of primary (used by udp)
	 */
	int deliver_packets;
	struct stable_buffer *stable_buffer;
	struct send_buffer *send_buffer;

	/*those fields should be moved inside a per-tcp struct together with tcp_param...*/	
	__u32 my_initial_out_seq;
	__u32 in_initial_seq;
	__u32 idelta_seq;
	__u32 odelta_seq;
};

void get_ft_filter(struct net_filter_info* filter);
void put_ft_filter(struct net_filter_info* filter);
char* print_filter_id(struct net_filter_info *filter);

int ft_is_replicated(struct task_struct *task);
int ft_is_primary_replica(struct task_struct *task);
int ft_is_secondary_replica(struct task_struct *task);
int ft_is_primary_after_secondary_replica(struct task_struct *task);
void ft_modify_replica_type(struct task_struct *tsk, int type);
int update_replica_type_after_failure(void);
struct pcn_kmsg_long_message;
void send_to_all_secondary_replicas(struct ft_pop_rep* ft_popcorn, struct pcn_kmsg_long_message* msg, int msg_size);
int is_there_any_secondary_replica(struct ft_pop_rep* ft_popcorn);

int maybe_create_replicas(void);
struct task_struct;
int copy_replication(unsigned long flags, struct task_struct *tsk);

#define FT_SYSCALL_CONTINUE 0
#define FT_SYSCALL_DROP 1
void ft_send_syscall_info(struct ft_pop_rep *replica_group, struct ft_pid *primary_pid, int syscall_id, char* syscall_info, unsigned int syscall_info_size);
void ft_send_syscall_info_from_work(struct ft_pop_rep *replica_group, struct ft_pid *primary_pid, int syscall_id, char* syscall_info, unsigned int syscall_info_size);
void* ft_wait_for_syscall_info(struct ft_pid *secondary, int id_syscall);
void* ft_get_pending_syscall_info(struct ft_pid *pri_after_sec, int id_syscall);
int flush_syscall_info(void);

struct timeval;
struct timezone;
long ft_gettimeofday(struct timeval __user * tv, struct timezone __user * tz);
struct kiocb;
struct msghdr;
int ft_before_syscall_send_family(struct kiocb *iocb, struct socket *sock,
                                       struct msghdr *msg, size_t size, int* ret);
int ft_after_syscall_send_family(struct socket *sock, int ret);
int ft_before_syscall_rcv_family(struct kiocb *iocb, struct socket *sock,
                                       struct msghdr *msg, size_t size, int flags, int* ret);
int ft_after_syscall_rcv_family(struct kiocb *iocb, struct socket *sock,
                                       struct msghdr *msg, size_t size, int flags, int ret);
struct request_sock_queue;
struct sock *ft_syscall_accept(struct request_sock_queue *queue, struct sock *parent, int flags, int* err);

int remove_and_copy_from_stable_buffer(struct stable_buffer *stable_buffer, struct iovec* iov, int size);
int insert_in_send_buffer_and_csum(struct send_buffer *send_buffer, struct iovec *iov, int iovlen, int size, __wsum *csum);
int remove_and_copy_from_stable_buffer_no_wait(struct stable_buffer *stable_buffer, struct iovec *iov, int size);
int trim_stable_buffer_in_filters(void);
int flush_send_buffer_in_filters(void);
int send_zero_window_in_filters(void);

#define DUMMY_DRIVER "ft_dummy_driver"

struct tcp_request_sock;

int create_filter(struct task_struct *task, struct sock *sk, gfp_t priority);
void ft_listen_init(struct sock* sk);
//int create_filter_accept(struct task_struct *task, struct socket *newsock,struct socket *sock);
void ft_grown_mini_filter(struct sock* sk, struct request_sock *req);
int ft_create_mini_filter(struct request_sock *req, struct sock *sk, struct sk_buff *skb);
void ft_change_to_time_wait_filter(struct sock *sk, struct inet_timewait_sock *tw);
void ft_deactivate_sk_after_time_wait_filter(struct inet_timewait_sock *tw);
void ft_check_tcp_init_param(struct net_filter_info* filter, struct sock* sk, struct request_sock *req);
int ft_check_tcp_timestamp(struct sock* sk);
void ft_activate_grown_filter(struct net_filter_info* filter);
struct request_sock *ft_reqsk_queue_find_remove(struct request_sock_queue *queue, __be32 daddr, __be16 dport);
struct request_sock *ft_reqsk_queue_find(struct request_sock_queue *queue, __be32 daddr, __be16 dport);
int flush_pending_pckt_in_filters(void);
int update_filter_type_after_failure(void);
int ft_is_filter_primary(struct net_filter_info* filter);
int ft_is_filter_primary_after_secondary(struct net_filter_info* filter);
int ft_is_filter_secondary(struct net_filter_info* filter);

#endif
