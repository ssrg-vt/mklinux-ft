/*
 * ft_replication.h
 *
 * Author: Marina
 */

#ifndef FT_REPLICATION_H_
#define FT_REPLICATION_H_

#include <linux/list.h>
#include <linux/kref.h>
#include <linux/spinlock_types.h>
#include <linux/wait.h>

#define FT_POPCORN

/* int replica_type of struct task_struct can be only one of the 
 * following:
 */
#define NOT_REPLICATED 0
#define PRIMARY_REPLICA 1
#define SECONDARY_REPLICA 2
#define POTENTIAL_PRIMARY_REPLICA 3
#define POTENTIAL_SECONDARY_REPLICA 4
#define ROOT_POT_PRIMARY_REPLICA 5
#define REPLICA_DESCENDANT 6
#define NEW_PRIMARY_REPLICA_DESCENDANT 7
#define NEW_SECONDARY_REPLICA_DESCENDANT 8
/****/

#define WAIT_ANSWER_TIMEOUT_SECOND 5
#define WAIT_PCKT_MAX 5
#define WAIT_CROSS_FILTER_MAX 1

/*by seeing include/asm-generic/errno.h seems to be the next available...*/
#define ENOFTREP 134

/* int filter_type of struct socket can be only one of
 * the following:
 */
#define FT_FILTER_DISABLE 0x0
#define FT_FILTER_ENABLE 0x1
/****/

/* int type of struct net_filter_info can be one 
 * of the previous used for struct socket,
 * masked with one of the following:
 */
#define FT_FILTER_SECONDARY_REPLICA 0x2
#define FT_FILTER_PRIMARY_REPLICA 0x4

#define FT_FILTER_FAKE 0x8
#define FT_FILTER_CHILD 0x10
/****/

/* Linux-like identifier for a replica.
 * It is the standard pid_t of the thread and the kernel
 * id that gave that pid.
 *
 * NOTE: each replica will have its own pid in the kernel in which
 * it is running => replicas do no share this identifier.
 */
struct replica_id{
        int kernel;
        pid_t pid;
};

struct replica_id_list{
        struct list_head replica_list_member;
        struct replica_id replica;
};

/* Identifier used by struct ft_pop_rep.
 * 
 * Groups of replicas on different kernels that are associated 
 * (they are generated by the same replicated process)
 * will have the same identifier.
 */
struct ft_pop_rep_id{
        int kernel;
        int id;
};

/* Identifier for replicas in ft-popcorn.
 * The same replica in different kernels will have the same ft_pid.
 * It is a one-to-one mapping for each replicated thread in popcorn
 * (the same replicated thread will have the same ft_pid in all kernels).
 */
struct ft_pid{
        int level;
        int* id_array;
	struct ft_pop_rep_id ft_pop_id;
};
int are_ft_pid_equals(struct ft_pid* first, struct ft_pid* second);
char* print_ft_pid(struct ft_pid* pid);

/* This is a struct with all replication info need by a group of replica.
 * 
 * The struct is supposed to be created by the first thread that is replicated
 * on a kernel (the primary or secondary replicas) and shared after with all its descendants
 * (which compose the replica group on a kernel)
 * 
 * The corresponding replica groups in different kernels will have the same
 * struct ft_pop_rep_id identifier.
 */
struct ft_pop_rep{
	struct kref kref;
	struct ft_pop_rep_id id;
	int replication_degree;
	struct replica_id primary_replica;
	struct replica_id_list secondary_replicas_head;
};
void get_ft_pop_rep(struct ft_pop_rep* ft_pop);
void put_ft_pop_rep(struct ft_pop_rep* ft_pop);

struct sk_buff;
struct ft_sk_buff_list{
	struct list_head list_member;
	struct sk_buff* skbuff;
	long long pckt_id;
	__wsum csum;
};

struct socket;
struct sock;

struct tcp_init_param{
        __u32 write_seq;
        __u16 inet_id;
        __be16 sport;
        __be16 dport;
        __be32 daddr;
        __be32 saddr;
        __be32 rcv_saddr;
	__u32 snt_isn;
	__u32 snt_synack;
};

struct request_sock;
/* struct used for networking filter on ft-popcorn.
 * 
 * If replicated, each socket will have its own reference to a filter
 * defined by this struct.
 * 
 * The filter is uniquely identied in a kernel by its ft-pid and id,
 * but same groups of replicas in different kernels will generate the same
 * filter identifiers from the same corresponding sockets.
 */
struct net_filter_info{
	struct list_head list_member;
	struct kref kref;
	struct ft_pop_rep* ft_popcorn;
	struct sock* ft_sock;
	struct request_sock* ft_req; //to use only if it is still a minisocket at the place of ft_sock
	
	/* NOTE creator and id compose the identifier.
	 * correspondig sockets between kernels will have the same 
	 * idetifier.
	 * In case the filter is a child filter, also daddr and dport 
	 * of tcp param are part of the identifier.
	 */
	struct ft_pid creator;
	int id;

	volatile int type;
	spinlock_t lock;
	volatile long long local_tx;
	volatile long long primary_tx;
	long long local_rx;
	long long primary_rx;
	wait_queue_head_t* wait_queue;
	struct workqueue_struct *rx_copy_wq;
	struct ft_sk_buff_list skbuff_list;

	volatile int primary_connect_id;
	int local_connect_id;
	volatile int primary_accept_id;
        int local_accept_id;
	struct tcp_init_param tcp_param;
};
void get_ft_filter(struct net_filter_info* filter);
void put_ft_filter(struct net_filter_info* filter);
char* print_filter_id(struct net_filter_info *filter);

int ft_is_replicated(struct task_struct *task);
int ft_is_primary_replica(struct task_struct *task);
int ft_is_secondary_replica(struct task_struct *task);
struct pcn_kmsg_long_message;
void send_to_all_secondary_replicas(struct ft_pop_rep* ft_popcorn, struct pcn_kmsg_long_message* msg, int msg_size);

int maybe_create_replicas(void);
struct task_struct;
int copy_replication(unsigned long flags, struct task_struct *tsk);
struct timeval;
struct timezone;

#define FT_SYSCALL_CONTINUE 0
#define FT_SYSCALL_DROP 1
void ft_send_syscall_info(struct ft_pop_rep *replica_group, struct ft_pid *primary_pid, int syscall_id, char* syscall_info, unsigned int syscall_info_size);
void ft_send_syscall_info_from_work(struct ft_pop_rep *replica_group, struct ft_pid *primary_pid, int syscall_id, char* syscall_info, unsigned int syscall_info_size);
void* ft_wait_for_syscall_info(struct ft_pid *secondary, int id_syscall);

long ft_gettimeofday(struct timeval __user * tv, struct timezone __user * tz);

#define DUMMY_DRIVER "ft_dummy_driver"

struct tcp_request_sock;

#define FT_TX_OK 0
#define FT_TX_DROP 1
int net_ft_tx_filter(struct sock* sk, struct sk_buff *skb);
int net_ft_rx_filter(struct sk_buff *skb);
int create_filter(struct task_struct *task, struct sock *sk, gfp_t priority);
//int create_filter_accept(struct task_struct *task, struct socket *newsock,struct socket *sock);
void ft_grown_mini_filter(struct sock* sk, struct request_sock *req);
int ft_create_mini_filter(struct request_sock *req, struct sock *sk, struct sk_buff *skb);
void ft_check_tcp_init_param(struct net_filter_info* filter, struct sock* sk, struct request_sock *req);
int ft_check_tcp_timestamp(struct sock* sk);
void ft_activate_grown_filter(struct net_filter_info* filter);

#endif
