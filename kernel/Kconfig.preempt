
choice
	prompt "Preemption Model"
	default PREEMPT_NONE

config PREEMPT_NONE
	bool "No Forced Preemption (Server)"
	help
	  This is the traditional Linux preemption model, geared towards
	  throughput. It will still provide good latencies most of the
	  time, but there are no guarantees and occasional longer delays
	  are possible.

	  Select this option if you are building a kernel for a server or
	  scientific/computation system, or if you want to maximize the
	  raw processing power of the kernel, irrespective of scheduling
	  latencies.

config PREEMPT_VOLUNTARY
	bool "Voluntary Kernel Preemption (Desktop)"
	help
	  This option reduces the latency of the kernel by adding more
	  "explicit preemption points" to the kernel code. These new
	  preemption points have been selected to reduce the maximum
	  latency of rescheduling, providing faster application reactions,
	  at the cost of slightly lower throughput.

	  This allows reaction to interactive events by allowing a
	  low priority process to voluntarily preempt itself even if it
	  is in kernel mode executing a system call. This allows
	  applications to run more 'smoothly' even when the system is
	  under load.

	  Select this if you are building a kernel for a desktop system.

config PREEMPT
	bool "Preemptible Kernel (Low-Latency Desktop)"
	help
	  This option reduces the latency of the kernel by making
	  all kernel code (that is not executing in a critical section)
	  preemptible.  This allows reaction to interactive events by
	  permitting a low priority process to be preempted involuntarily
	  even if it is in kernel mode executing a system call and would
	  otherwise not be about to reach a natural preemption point.
	  This allows applications to run more 'smoothly' even when the
	  system is under load, at the cost of slightly lower throughput
	  and a slight runtime overhead to kernel code.

	  Select this if you are building a kernel for a desktop or
	  embedded system with latency requirements in the milliseconds
	  range.

endchoice

choice
	prompt "RCU Implementation"
	default CLASSIC_RCU

config CLASSIC_RCU
	bool "Classic RCU"
	help
	  This option selects the classic RCU implementation that is
	  designed for best read-side performance on non-realtime
	  systems.
	  
	  Select this option if you are unsure.

config TREE_RCU
	bool "Tree-based hierarchical RCU"
	help
	  This option selects the RCU implementation that is
	  designed for very large SMP system with hundreds or
	  thousands of CPUs.

config PREEMPT_RCU
	bool "Preemptible RCU"
	depends on PREEMPT
	help
	  This option reduces the latency of the kernel by making certain
	  RCU sections preemptible. Normally RCU code is non-preemptible, if
	  this option is selected then read-only RCU sections become
	  preemptible. This helps latency, but may expose bugs due to
	  now-naive assumptions about each RCU read-side critical section
	  remaining on a given CPU through its execution.

endchoice

config RCU_TRACE
	bool "Enable tracing for RCU"
	depends on TREE_RCU || PREEMPT_RCU
	help
	  This option provides tracing in RCU which presents stats
	  in debugfs for debugging RCU implementation.

	  Say Y here if you want to enable RCU tracing
	  Say N if you are unsure.

config RCU_FANOUT
	int "Tree-based hierarchical RCU fanout value"
	range 2 64 if 64BIT
	range 2 32 if !64BIT
	depends on TREE_RCU
	default 64 if 64BIT
	default 32 if !64BIT
	help
	  This option controls the fanout of hierarchical implementations
	  of RCU, allowing RCU to work efficiently on machines with
	  large numbers of CPUs.  This value must be at least the cube
	  root of NR_CPUS, which allows NR_CPUS up to 32,768 for 32-bit
	  systems and up to 262,144 for 64-bit systems.

	  Select a specific number if testing RCU itself.
	  Take the default if unsure.

config RCU_FANOUT_EXACT
	bool "Disable tree-based hierarchical RCU auto-balancing"
	depends on TREE_RCU
	default n
	help
	  This option forces use of the exact RCU_FANOUT value specified,
	  regardless of imbalances in the hierarchy.  This is useful for
	  testing RCU itself, and might one day be useful on systems with
	  strong NUMA behavior.

	  Without RCU_FANOUT_EXACT, the code will balance the hierarchy.

	  Say n if unsure.

	
