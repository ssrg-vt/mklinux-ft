#
# Config file for autotest.pl
#
# Note, all paths must be absolute
#

# Almost all options may be overwritten per test run, by appending
# a [x] to the config. For example, to change the test type for
# the third iteration of tests, you can specify:
#  (1 is for the first test, 2 for the second, and so on)
#
#  TEST_TYPE[3] = build
#
# The options that can not be changed like this are:
#  NUM_TESTS
#  LOG_FILE
#  CLEAR_LOG
#  POWEROFF_ON_SUCCESS
#  REBOOT_ON_SUCCESS
#

#### Mandatory Config Options ####

# The machine hostname that you will test
#MACHINE = target

# The box is expected to have ssh on normal bootup, provide the user
#  (most likely root, since you need privileged operations)
#SSH_USER = root

# The directory that contains the Linux source code
#BUILD_DIR = /home/test/linux.git

# The directory that the objects will be built
# (can not be same as BUILD_DIR)
#OUTPUT_DIR = /home/test/build/target

# The location of the compiled file to copy to the target
# (relative to OUTPUT_DIR)
#BUILD_TARGET = arch/x86/boot/bzImage

# The place to put your image on the test machine
#TARGET_IMAGE = /boot/vmlinuz-test

# A script or command to reboot the box
# Here is a digital loggers power switch example
#POWER_CYCLE = wget --no-proxy -O /dev/null -q  --auth-no-challenge 'http://admin:admin@power/outlet?5=CCL'
# Here is an example to reboot a virtual box on the current host
# with the name "Guest".
#POWER_CYCLE = virsh list | grep '\<Guest\>' | awk '{printf ("%d", $1)}' | xargs virsh destroy; sleep 5; virsh start Guest

# The script or command that reads the console
#  If you use ttywatch server, something like the following would work.
#CONSOLE = nc -d localhost 3001
# For a virtual machine with guest name "Guest".
#CONSOLE =  virsh console `virsh list | grep '\<Guest\>' | awk '{printf ("%d", $1)}'`

# Required version ending to differentiate the test
# from other linux builds on the system.
#LOCALVERSION = -test

# The grub title name for the test kernel to boot
# (Only mandatory if REBOOT_TYPE = grub)
#
# For example, if in the /boot/grub/menu.lst the test kernel title has:
# title Test Kernel
#GRUB_MENU = Test Kernel

# A script to reboot the target into the test kernel
# (Only mandatory if REBOOT_TYPE = script)
#REBOOT_SCRIPT =

#### Optional Config Options (all have defaults) ####

# The number of tests to run (default 5)
#NUM_TESTS = 5

# The default test type (default test)
# The test types may be:
#   build - only build the kernel, do nothing else
#   boot - build and boot the kernel
#   test - build, boot and if TEST is set, run the test script
#   bisect - Perform a bisect on the kernel (see BISECT_TYPE below)
#   patchcheck - Do a test on a series of commits in git (see PATCHCHECK below)
#TEST_TYPE = test

# The build type is any make config type or a command.
#  (default randconfig)
#   nobuild - skip the clean and build step
#BUILD_TYPE = randconfig

# The make command (default make)
# If you are building a 32bit x86 on a 64 bit host
#MAKE_CMD = CC=i386-gcc AS=i386-as make ARCH=i386

# If you need an initrd, you can add a script or code here to install
# it. The environment variable KERNEL_VERSION will be set to the
# kernel version that is used.
#POST_INSTALL = ssh user@target /sbin/mkinitrd --allow-missing -f /boot/initramfs-test.img $KERNEL_VERSION

# Way to reboot the box to the test kernel.
# Only valid options so far are "grub" and "script"
# (default grub)
# If you specify grub, it will assume grub version 1
# and will search in /boot/grub/menu.lst for the title $GRUB_MENU
# and select that target to reboot to the kernel. If this is not
# your setup, then specify "script" and have a command or script
# specified in REBOOT_SCRIPT to boot to the target.
#REBOOT_TYPE = grub

# Line to define success in output. (default "login:")
# This is what the line contains, not the entire line. If you need
# the entire line to match, then use regural expression syntax like
#  ^MyBox Login:$
#SUCCESS_LINE = login:

# As the test reads the console, after it hits the SUCCESS_LINE
# the time it waits for the monitor to settle down between reads
# can usually be lowered.
# (in seconds) (default 1)
#BOOTED_TIMEOUT = 1

# The timeout in seconds when we consider the box hung after
# the console stop producing output.
# (default 120)
#TIMEOUT = 120

# The location on the host where to write temp files
# (default /tmp/autotest)
#TMP_DIR = /tmp/autotest

# In between tests, a reboot of the box may occur, and this
# is the time to wait for the console after it stops producing
# output. Some machines may not produce a large lag on reboot
# so this should accommodate it.
# (default 60)
#SLEEP_TIME = 60

# The time in between bisects to sleep (in seconds)
# Can be less than SLEEP_TIME since bisects do more work
# in between boots. (default 60)
#BISECT_SLEEP_TIME = 60

# Build without doing a make mrproper, or removing .config
# (default 0)
#BUILD_NOCLEAN = 0

# Reboot the target box on error (default 0)
#REBOOT_ON_ERROR = 0

# Power off the target on error (ignored if REBOOT_ON_ERROR is set)
# (default 0)
#POWEROFF_ON_ERROR = 0

# Power off the target after all tests have completed successfully
# (default 0)
#POWEROFF_ON_SUCCESS = 0

# Reboot the target after all test completed successfully (default 1)
# (ignored if POWEROFF_ON_SUCCESS is set)
#REBOOT_ON_SUCCESS = 1

# In case there's isses with rebooting, you can specify this
# to always powercycle after this amount of time after calling
# reboot.
# Note, POWERCYCLE_AFTER_REBOOT = 0 does NOT disable it. It just
# makes it powercycle immediately after rebooting. Do not define
# it if you do not want it.
# (default undefined)
#POWERCYCLE_AFTER_REBOOT = 5

# In case there's isses with halting, you can specify this
# to always poweroff after this amount of time after calling
# halt.
# Note, POWEROFF_AFTER_HALT = 0 does NOT disable it. It just
# makes it poweroff immediately after halting. Do not define
# it if you do not want it.
# (default undefined)
#POWEROFF_AFTER_HALT = 20

# Stop testing if a build fails. If set, the script will end if
# a failure is detected, otherwise it will save off the .config,
# dmesg and bootlog in a directory called
# MACHINE-TEST_TYPE_BUILD_TYPE-fail-yyyymmddhhmmss
# if the STORE_FAILURES directory is set.
# (default 1)
# Note, even if this is set to zero, there are some errors that still
# stop the tests.
#DIE_ON_FAILURE = 1

# Directory to store failure directories on failure. If this is not
# set, DIE_ON_FAILURE=0 will not save off the .config, dmesg and
# bootlog.
#STORE_FAILURES = /home/test/failures

# A script or command to power off the box (default undef)
# Needed for POWEROFF_ON_ERROR and SUCCESS
# Example for digital loggers power switch:
#POWER_OFF = wget --no-proxy -O /dev/null -q  --auth-no-challenge 'http://admin:admin@power/outlet?5=OFF'
# Example for a virtual guest call "Guest".
#POWER_OFF = virsh list | grep '\<GuestF12\>' | awk '{printf ("%d", $1)}' | xargs virsh destroy

# Any build options for the make (default "")
#BUILD_OPTIONS = -j20

# Optional log file to write the status (recommended)
# (default undef)
#LOG_FILE = /home/test/logfiles/target.log

# Remove old logfile if it exists before starting all tests.
# (default 0)
#CLEAR_LOG = 0

# Test to run if there is a successful boot and TEST_TYPE is test.
# Must exit with 0 on success and non zero on error
# default (undef)
#TEST = ssh user@machine /root/run_test
#TEST[1] = ssh root@mxtest /root/run_test

# The min config that is needed to build for the machine
# A nice way to get this to work, is to do a "lsmod > mymods" on the target
# copy it to the build server, and then run "make LSMOD=mymods localyesconfig".
# Then copy all the options that are set: "grep '^CONFIG' > /home/test/config-min"
#
#  You might want to set:
#   CONFIG_CMDLINE="<your options here>"
#  randconfig may set the above and override your real command
#  line options.
# (default undef)
#MIN_CONFIG = /home/test/config-min

# Sometimes there's options that just break the boot and
# you do not care about. Here are a few:
#   # CONFIG_STAGING is not set
#  Staging drivers are horrible, and can break the build.
#   # CONFIG_SCSI_DEBUG is not set
#  SCSI_DEBUG may change your root partition
#   # CONFIG_KGDB_SERIAL_CONSOLE is not set
#  KGDB may cause oops waiting for a connection that's not there.
# This option points to the file containing config options that will be prepended
# to the MIN_CONFIG (or be the MIN_CONFIG if it is not set)
# before running it through randconfig
# (default undef)
#ADD_CONFIG = /home/test/config-broken

#### Per test run options ####
# These are options are per build only. The only exist with the [x]
# syntax, and there is no general option.
#
# All are optional and undef by default
#
# CHECKOUT[x] = branch
#
#  If the BUILD_DIR is a git repository, then you can set this option
#  to checkout the given branch before running the TEST. If you
#  specify this for the first run, that branch will be used for
#  all preceding tests until a new CHECKOUT[x] is set.
#
# For TEST_TYPE[x] = patchcheck
#
#  This expects the BUILD_DIR to be a git repository, and
#  will checkout the PATCHCHECK_START[x].
#
#  PATCHCHECK_START[x] is required and is the first patch to
#   test (the SHA1 of the commit).
#
#  PATCHCHECK_END[x] is the last patch to check (default HEAD)
#
#  PATCHCHECK_TYPE[x] is required and is the type of test to run:
#      build, boot, test.
#
#   Note, the build test will look for warnings, if a warning occurred
#     in a file that a commit touches, the build will fail.
#
#   If BUILD_NOCLEAN is set, then make mrproper will not be run on
#   any of the builds, just like all other TEST_TYPE tests. But
#   what makes patchcheck different from the other tests, is if
#   BUILD_NOCLEAN is not set, only the first and last patch run
#   make mrproper. This helps speed up the test.
#
# Example:
#   TEST_TYPE[1] = patchcheck
#   CHECKOUT[1] = mybranch
#   PATCHCHECK_TYPE[1] = boot
#   PATCHCHECK_START[1] = 747e94ae3d1b4c9bf5380e569f614eb9040b79e7
#   PATCHCHEKC_END[1] = b8b2663bd7c9da04ac804659b9f617c199d0252c
#
#
# For TEST_TYPE[x] = bisect
#
# You can specify a git bisect if the BUILD_DIR is a git repository.
# The MIN_CONFIG will be used for all builds of the bisect. The build type
# used for bisecting is oldconfig.
#
# BISECT_TYPE[x] is the type of test to perform:
#	build	- bad fails to build
#	boot	- bad builds but fails to boot
#	test	- bad boots but fails a test
#
# BISECT_GOOD[x] is the commit (SHA1) to label as good
# BISECT_BAD[x] is the commit to label as bad
#
# The above three options are required for a bisect operation.
#
# BISECT_REPLAY[x] = /path/to/replay/file (optional, default undefined)
#
#   If an operation failed in the bisect that was not expected to
#   fail. Then the test ends. The state of the BUILD_DIR will be
#   left off at where the failur occurred. You can examine the
#   reason for the failure, and perhaps even find a git commit
#   that would work to continue with. You can run:
#
#   git bisect log > /path/to/replay/file
#
#   and if BISECT_REPLAY[x] is set, the test will run git bisect replay
#   before continuing with the bisect.
#
# BISECT_START[x] = commit (optional, default undefined)
#
#   As with BISECT_REPLAY[x], if the test failed on a commit that
#   just happen to have a bad commit in the middle of the bisect,
#   and you need to skip it. If BISECT_START[x] is defined, it
#   will checkout that commit before continuing with the bisect.
#
#   Note, BISECT_REPLAY[x] is executed before BISECT_START[x].
#
# BISECT_REVERSE[x] = 1 (optional, default 0)
#
#   In those strange instances where it was broken forever
#   and you are trying to find where it started to work!
#   Set BISECT_GOOD[x] to the commit that was last known to fail
#   Set BISECT_BAD[x] to the commit that is known where it started
#   to work. With BISECT_REVERSE[x] = 1, The test will consider
#   failures as good, and success as bad.
#
# BISECT_CHECK[x] = 1 (optional, default 0)
#
#   Just to be sure the good is good and bad is bad, setting
#   BISECT_CHECK[x] to 1 will start the bisect by first checking
#   out BISECT_BAD[x] and makes sure it fails, then it will check
#   out BISECT_GOOD[x] and makes sure it succeeds before starting
#   the bisect (it works for BISECT_REVERSE[x] too).
#
#   You can limit the test to just check BISECT_GOOD[x] or
#   BISECT_BAD[x] with BISECT_CHECK[x] = good or
#   BISECT_CHECK[x] = bad, respectively.
#
# Example:
#   TEST_TYPE[1] = bisect
#   BISECT_GOOD[1] = v2.6.36
#   BISECT_BAD[1] = b5153163ed580e00c67bdfecb02b2e3843817b3e
#   BISECT_TYPE[1] = build
#   MIN_CONFIG[1] = /home/test/config-bisect
